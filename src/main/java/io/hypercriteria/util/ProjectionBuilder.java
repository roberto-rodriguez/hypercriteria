package io.hypercriteria.util;

import io.hypercriteria.Annotations;
import io.hypercriteria.Annotations.ConstructorName;
import io.hypercriteria.Criteria;
import io.hypercriteria.criterion.ProjectionList;
import java.beans.ConstructorProperties;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Parameter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 *
 * @author rrodriguez
 */
public class ProjectionBuilder {

//    public static Optional<Projection> build(QueryContext ctx, Projection projection) { 
//
//            if (projection instanceof SimpleProjection simpleProjection) {
//                EntityManager em = criteria.getEntityManager();
//                Class<?> rootEntityClass = criteria.getEntityType();
//                simpleProjection.getPathInfo(em, rootEntityClass);
//
//                criteria.getjoinInfoMap().putAll(simpleProjection.getFieldsMappingToAliasJoinTypeMap());
//            }
//        

//    public static ProjectionList projectionList(Criteria criteria) {
//        Class dtoType = criteria.getResultType();
//
//        List<String> fieldList = listFields(criteria);
//
//        Map projectionMappingOverrides = new HashMap();
//        Field[] fields = dtoType.getDeclaredFields();
//
//        for (Field field : fields) {
//            if (field.isAnnotationPresent(Annotations.Mapping.class)) {
//                projectionMappingOverrides.put(field.getName(), field.getAnnotation(Annotations.Mapping.class).value());
//            }
//        }
//
//        ProjectionList projectionList = new ProjectionList(dtoType);
//
//        for (String fieldName : fieldList) {
//            String fieldPath = fieldName;
//            String valueName = fieldName;
//
//            if (projectionMappingOverrides.containsKey(fieldPath)) {
//                fieldPath = (String) projectionMappingOverrides.get(fieldPath);
//            }
////TODO
////            fieldPath = extractAliasAndJoinType(fieldPath, criteria.getjoinInfoMap());
////
////            projectionList.add(HyperCriteria.property(fieldPath).as(valueName));
//        }
//
//        return projectionList;
//    }
//
//    private static List<String> listFields(Criteria criteria) {
//        Class dtoType = criteria.getResultType();
//        Optional<String> constructorName = criteria.getConstructorName();
//
//        Constructor<?>[] constructors = dtoType.getDeclaredConstructors();
//
//        Constructor<?> targetConstructor;
//        List<String> fieldList;
//
//        if (constructorName.isPresent()) {
//            targetConstructor = Arrays.stream(constructors)
//                    .filter(c -> {
//                        ConstructorName annotation = c.getAnnotation(ConstructorName.class);
//                        return annotation != null && constructorName.get().equals(annotation.value());
//                    })
//                    .findFirst()
//                    .orElseThrow(() -> new IllegalArgumentException(
//                    String.format("No constructor annotated with @ConstructorName(\"%s\") in %s",
//                            constructorName.get(), dtoType.getName())
//                    + dtoType.getName()));
//
//            targetConstructor.setAccessible(true);
//
//            fieldList = getFieldList(targetConstructor);
//        } else {
//            // If no constructorName is specified in the Criteria, then look for the 
//            //constructor with most parameters
//            targetConstructor = Arrays.stream(constructors)
//                    .max(Comparator.comparingInt(Constructor::getParameterCount))
//                    .orElseThrow(() -> new IllegalStateException("Unable to pick a constructor for " + dtoType.getName()));
//
//            //When constructor is generated by @AllArgsConstructor, lombok does not include field names by default.  
//            //To get the actual name of the fields from the constructor, we rely lombok annotation ConstructorProperties
//            //IMPORTANT!!! This required client configuring lombok.anyConstructor.addConstructorProperties = true in lombok.config on the project's root.
//            Optional<ConstructorProperties> lombokConstructorProperties
//                    = Arrays.stream(targetConstructor.getAnnotations())
//                            .filter(a -> a.annotationType() == ConstructorProperties.class)
//                            .map(ConstructorProperties.class::cast)
//                            .findFirst();
//
//            if (lombokConstructorProperties.isPresent()) {
//                fieldList = Arrays.asList(lombokConstructorProperties.get().value()); // real names from annotation 
//            } else {
//                fieldList = getFieldList(targetConstructor);
//            }
//        }
//
//        return fieldList;
//    }

    /**
     * Extracts the effective projection alias from a join-aware field path and
     * populates a map of join paths to their corresponding alias and join type.
     *
     * <p>
     * The field path supports the following join delimiters:
     * </p>
     *
     * <ul>
     * <li><b>.</b> → LEFT join (default)</li>
     * <li><b>&gt;</b> → RIGHT join</li>
     * <li><b>&lt;&gt;</b> → INNER join</li>
     * </ul>
     *
     * <p>
     * A join delimiter may also appear at the beginning of the path to
     * explicitly define the join type of the root element.
     * </p>
     *
     * <h3>Alias extraction rules</h3>
     *
     * <ul>
     * <li>If the path is {@code null}, empty, or contains a single segment, it
     * is returned unchanged and no mappings are added.</li>
     * <li>If the path contains exactly two segments, the full path is returned
     * and only the root segment is added to the map.</li>
     * <li>If the path contains three or more segments, the last two segments
     * are returned.</li>
     * </ul>
     *
     * <h3>Join registration rules</h3>
     *
     * <ul>
     * <li>The root segment is always registered as a self-mapping.</li>
     * <li>Each intermediate path (excluding the final returned path) is
     * registered with its alias and join type.</li>
     * <li>The returned (leaf) path is <b>never</b> added to the map.</li>
     * </ul>
     *
     * <h3>Join precedence</h3>
     *
     * <pre>{@code
     * INNER > RIGHT > LEFT
     * }</pre>
     *
     * <p>
     * Existing mappings are overridden only if the new join type has higher
     * precedence.
     * </p>
     *
     * @param fieldPath the join-aware field path
     * @param fieldsMappingAlias map populated with alias and join metadata
     * @return the effective projection alias
     */
//    public static String extractAliasAndJoinType(
//            String fieldPath,
//            LinkedHashMap<String, AliasJoinType> fieldsMappingAlias) {
//
//        if (fieldPath == null || fieldPath.isEmpty()) {
//            return fieldPath;
//        }
//
//        List<String> parts = new ArrayList<>();
//        List<JoinType> joinTypes = new ArrayList<>();
//
//        int i = 0;
//        JoinType rootJoinType = JoinType.LEFT;
//
//        // Detect explicit root join
//        if (fieldPath.startsWith("<>")) {
//            rootJoinType = JoinType.INNER;
//            i = 2;
//        } else if (fieldPath.startsWith(">")) {
//            rootJoinType = JoinType.RIGHT;
//            i = 1;
//        }
//
//        StringBuilder current = new StringBuilder();
//
//        while (i < fieldPath.length()) {
//            if (fieldPath.startsWith("<>", i)) {
//                parts.add(current.toString());
//                joinTypes.add(JoinType.INNER);
//                current.setLength(0);
//                i += 2;
//            } else if (fieldPath.charAt(i) == '>') {
//                parts.add(current.toString());
//                joinTypes.add(JoinType.RIGHT);
//                current.setLength(0);
//                i++;
//            } else if (fieldPath.charAt(i) == '.') {
//                parts.add(current.toString());
//                joinTypes.add(JoinType.LEFT);
//                current.setLength(0);
//                i++;
//            } else {
//                current.append(fieldPath.charAt(i));
//                i++;
//            }
//        }
//
//        parts.add(current.toString());
//
//        int len = parts.size();
//
//        if (len == 1) {
//            return fieldPath;
//        }
//
//        // Root mapping
//        putWithPrecedence(
//                fieldsMappingAlias,
//                parts.get(0),
//                parts.get(0),
//                rootJoinType
//        );
//
//        // Register intermediate joins only (exclude leaf)
//        for (int idx = 0; idx < len - 2; idx++) {
//            String key = parts.get(idx) + "." + parts.get(idx + 1);
//            putWithPrecedence(
//                    fieldsMappingAlias,
//                    key,
//                    parts.get(idx + 1),
//                    joinTypes.get(idx)
//            );
//        }
//
//        // Return leaf alias
//        if (len == 2) {
//            return parts.get(0) + "." + parts.get(1);
//        }
//
//        return parts.get(len - 2) + "." + parts.get(len - 1);
//    }
//
//    private static void putWithPrecedence(
//            Map<String, AliasJoinType> map,
//            String key,
//            String alias,
//            JoinType newJoinType) {
//
//        AliasJoinType existing = map.get(key);
//
//        if (existing == null || precedence(newJoinType) > precedence(existing.getJoinType())) {
//            map.put(
//                    key,
//                    AliasJoinType.builder()
//                            .alias(alias)
//                            .joinType(newJoinType)
//                            .build()
//            );
//        }
//    }
//
//    private static int precedence(JoinType joinType) {
//        return switch (joinType) {
//            case INNER ->
//                3;
//            case RIGHT ->
//                2;
//            case LEFT ->
//                1;
//            default ->
//                0;
//        };
//    }
    private static List<String> getFieldList(Constructor<?> targetConstructor) {
        Parameter[] params = targetConstructor.getParameters();
        return Arrays.stream(params)
                .map(Parameter::getName)
                .collect(Collectors.toList());
    }
}
